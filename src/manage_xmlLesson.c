/***************************************************************
 *  manage_xmlLesson.c                                          *
 *                                                              *
 *  Description:  Read XML lesson files generated by            *
 *                Tux4kids-Admin and write result files for it. *                                         *
 *  Author:       Vikas Singh 					*
 *                 vikassingh008@gmail.com ,2010 		*
 *  Copyright:    GPL v3 or later                               *
 *  							    	*
 *  						          	*
 *                                                          	*
 *                                                          	*
 *  TuxMath                                                 	*
 *  Part of "Tux4Kids" Project                              	*
 *  http://tux4kids.alioth.debian.org/                      	*
 ***************************************************************/

#include"globals.h"
#include <libxml/parser.h>
#include <libxml/tree.h>
#include"manage_xmlLesson.h" 
#include"schoolmode.h"
#include"SDL_extras.h"
#define PATH_MAX 4096

//Local Function prototypes for reading
void parse_cascade(xmlNode *);
void parse_lasergame(xmlNode *);
//Local Function prototypes for writing
//initialize read and write 
int init_readwrite(char *);
void clean_up();



//variables
  xmlDocPtr doc_read,doc_write;

xmlNodePtr root_write = NULL;  /* node pointer for writing */
    xmlDtdPtr dtd = NULL;  //writing
 xmlNode *root_read = NULL; //reading
int total_no_menus;  
    char buff[256];

  char menu_names[MAX_MENU_ITEMS][MENU_ITEM_LENGTH] = {{'\0'}};

char filepath[256],level_string[5];
int level=-1;

 xmlChar *wave;

//extern struct result_per_wave *result; //defined in factoroids.c

//char *xml_lesson_path;


int manage_xmlLesson(char *xml_lesson_path)
{
xmlNode *cur_node;
int i;
char fn[PATH_MAX];
char test_file[PATH_MAX]; //this files is used to extract time and date and then deleted
char *write_directory;

//time and date related variables
time_t filetime;
  struct stat filestat;
  struct tm datetime;
  FILE* fp; 


if(init_readwrite(xml_lesson_path)==-1)
return 0;


//input = ( struct input_per_wave *) malloc(MAX_WAVES * sizeof(struct input_per_wave));

 // if (input == NULL)
  //{
  //  printf("Allocation of input to store input values failed");
  //  return 0;
 // }

 for(i=0 , cur_node = root_read->children    ; cur_node != NULL   ;      cur_node = cur_node->next)
  {
     if ( cur_node->type == XML_ELEMENT_NODE  &&
          !xmlStrcmp(cur_node->name, (const xmlChar *) "fish" ) )
     {  
        if(display_screen(i)==-1)    // i highlights the next game to be played
           break;
       i++;   
        parse_cascade(cur_node);

          GenerateWordList(filepath);
          if(level ==1)
           PlayCascade( EASY );
          else 
          if(level ==2)
           PlayCascade( MEDIUM );
          else 
          if(level ==3)
           PlayCascade( HARD );
          else 
          if(level ==4)
           PlayCascade( INSANE );
              level=-1;
    //   game_score=factoroids_schoolmode(0,current_no_of_waves);
      // write_factors();  
 
     }

   else if ( cur_node->type == XML_ELEMENT_NODE  &&
          !xmlStrcmp(cur_node->name, (const xmlChar *) "comet" ) )
     { 
        if(display_screen(i)==-1)    // i highlights the next game to be played
           break;
        i++;         
        parse_lasergame(cur_node);

          GenerateWordList(filepath);
          if(level ==1)
           PlayLaserGame( EASY );
          else 
          if(level ==2)
          PlayLaserGame( MEDIUM );
          else 
          if(level ==3)
          PlayLaserGame( HARD );
          else 
          if(level ==4)
           PlayLaserGame( INSANE ); 
             level=-1;
      //  current_no_of_waves=parse_fractions(cur_node);
      // game_score=factoroids_schoolmode(1,current_no_of_waves);
      // write_fractions();   
     }
  

  }

  // --------------------------------------------------------------------------

 #ifdef BUILD_MINGW32
     write_directory = GetDefaultSaveDir(PROGRAM_NAME);
#else
     write_directory = strdup(getenv("HOME"));
#endif

      //Decide the write directory for writing result  
      write_directory= strdup(getenv("HOME"));




/* FIXME there must be a better method way to do than this    */ 
/*Extract date and time by writing a test file to the same directory*/
/* where we are going to write result and extracting date and time from it */
/*and then deleting that file. */
/* We're going to want to write the date.  Use the filetime  */
    /* rather than calling "time" directly, because "time"       */
    /* returns the time according to whatever computer is        */
    /* running tuxmath, and in a server/client mode it's likely  */
    /* that some of the clients' clocks may be wrong. Use      */
    /* instead the time according to the server on which the     */
    /* accounts are stored, which can be extracted from the      */
    /* modification time of the summary we just wrote.           */
	
snprintf(test_file, PATH_MAX, "%s/testfile",write_directory);
fp=fopen(test_file,"w");
if (fp){
fprintf(fp, "\ntest file");
fclose(fp);
} 
else {fprintf(stderr,"test file not written.\n");}
    
//time and date related code
if (stat(test_file,&filestat) == 0) {
      filetime = filestat.st_mtime;
    } else {
      filetime = time(NULL);
    }
localtime_r(&filetime,&datetime); /* generate broken-down time */

remove(test_file); //got date and time so remove the file






//write the result file
	snprintf(fn, PATH_MAX, "%s/result%d-%d-%d__%d:%d:%d.xml",write_directory,datetime.tm_year+1900, 
              datetime.tm_mon+1, datetime.tm_mday,datetime.tm_hour,datetime.tm_min,datetime.tm_sec);

      if( xmlSaveFormatFileEnc(fn, doc_write, "UTF-8", 1)==-1)
          fprintf(stderr,
              "\nError: couldn't write result file: "
              "%s\n",fn);
      else
         printf("\nResult file saved : %s\n",fn);


clean_up();

/*
* this is to debug memory for regression tests
 */
 xmlMemoryDump();
    return(0);

}


int init_readwrite(char *xml_lesson_path)
{

//code related to reading
xmlNode *cur_node;
  char fn[4096];
//char *lesson_path = "schoolmode/lessonData.xml";
 // snprintf(fn, 4096, "%s/images/%s", DATA_PREFIX, lesson_path);

snprintf(fn, 4096, "%s", xml_lesson_path);

int i;
  //xmlChar *Num_asteroids;
//int serial_number;

  // --------------------------------------------------------------------------
  // Open XML document
  // --------------------------------------------------------------------------

  doc_read = xmlParseFile(fn);

  if (doc_read == NULL) 
        printf("error: could not parse file %s \n",xml_lesson_path);
  else 
        printf("parsed file %s\n",xml_lesson_path);
  // --------------------------------------------------------------------------
  // XML root.
  // --------------------------------------------------------------------------

  /*Get the root element node */
  root_read = xmlDocGetRootElement(doc_read);
  
  // --------------------------------------------------------------------------
  // Must have root element, a name and the name must be "lessonData"
  // --------------------------------------------------------------------------
  
  if( !root_read || 
      !root_read->name ||
      xmlStrcmp(root_read->name,(const xmlChar *)"lessonData") ) 
  {
     xmlFreeDoc(doc_read);
     return -1;
  }

  // --------------------------------------------------------------------------
  // lessonData children: For each factors
  // --------------------------------------------------------------------------


  for(  i=0 , cur_node = root_read->children    ;   cur_node != NULL   ;    cur_node = cur_node->next)
  {
     if ( cur_node->type == XML_ELEMENT_NODE  &&
          !xmlStrcmp(cur_node->name, (const xmlChar *) "fish" ) )
     {  
            sprintf(menu_names[i], "%s", cur_node->name); 
            i++;
               //menu_names[i]=(char *)cur_node->name;
     }

   else if ( cur_node->type == XML_ELEMENT_NODE  &&
          !xmlStrcmp(cur_node->name, (const xmlChar *) "comet" ) )
     {  
                sprintf(menu_names[i], "%s", cur_node->name); 
                i++;
     }


  }

total_no_menus=i;



//code related to writing

#if !defined(LIBXML_TREE_ENABLED) || !defined(LIBXML_OUTPUT_ENABLED)
fprintf(stderr, "Tree support for writing XML result files not compiled in\n");
    return -1;
#endif
//Macro to check that the libxml version in use is compatible with the version the software has been compiled against
    LIBXML_TEST_VERSION;

    /* 
     * Creates a new document, a node and set it as a root node
     */
    doc_write = xmlNewDoc(BAD_CAST "1.0");
    root_write = xmlNewNode(NULL, BAD_CAST "resultData");
    xmlDocSetRootElement(doc_write, root_write);

    /*
     * Creates a DTD declaration. Isn't mandatory. 
     */
    dtd = xmlCreateIntSubset(doc_write, BAD_CAST "resultData", NULL, BAD_CAST "");
return 0;

}


//parse cascade
void parse_cascade(xmlNode *cur_node)
{
 xmlChar *filename,*level_xml;
 xmlNode *child_node;


       //printf("Element: %s \n", cur_node->name); 

        // For each child of factors: i.e. wave
        for(child_node = cur_node->children; child_node != NULL; child_node = child_node->next)
        {
           if ( cur_node->type == XML_ELEMENT_NODE  &&
                !xmlStrcmp(child_node->name, (const xmlChar *)"words_file") )
           {
             
            
              filename= xmlNodeGetContent(child_node);
              if(filename)
               {
                 //printf("         Wave: %s\n", wave);
                 sprintf(filepath ,"%s", filename); 

               }
              //xmlFree(filename);
           }          
          else if ( cur_node->type == XML_ELEMENT_NODE  &&
                !xmlStrcmp(child_node->name, (const xmlChar *)"level") )
           {
              
               //the level value is got from XML file
                level_xml= xmlNodeGetContent(child_node);
              if(level_xml)
               {
                 sprintf(level_string, "%s", level_xml); 
                 level=atoi(level_string);
                   

               }
              //xmlFree(level_xml);
           }          
         }


}


//parse lasergame
void parse_lasergame(xmlNode *cur_node)
{
 xmlChar *filename,*level_xml;
 xmlNode *child_node;


       //printf("Element: %s \n", cur_node->name); 

        // For each child of factors: i.e. wave
        for(child_node = cur_node->children; child_node != NULL; child_node = child_node->next)
        {
           if ( cur_node->type == XML_ELEMENT_NODE  &&
                !xmlStrcmp(child_node->name, (const xmlChar *)"words_file") )
           {
             
            
              filename= xmlNodeGetContent(child_node);
              if(filename)
               {
                 //printf("         Wave: %s\n", wave);
                 sprintf(filepath ,"%s", filename); 

               }
              //xmlFree(filename);
           }          
          else if ( cur_node->type == XML_ELEMENT_NODE  &&
                !xmlStrcmp(child_node->name, (const xmlChar *)"level") )
           {
              
               //the level value is got from XML file
                level_xml= xmlNodeGetContent(child_node);
              if(level_xml)
               {
                 sprintf(level_string, "%s", level_xml); 
                 level=atoi(level_string);
                   

               }
              //xmlFree(level_xml);
           }          
         }


}


void clean_up()
{


  

  /* Free all images and sounds used by SDL: */
  Cleanup_SDL_Text();

SDL_FreeSurface(screen);
  screen = NULL;
  
//free(input);
//free(result);
 


  SDL_Quit();
/*free the document read*/
  xmlFreeDoc(doc_read);
    /*free the document write*/
    xmlFreeDoc(doc_write);
  /*
   *Free the global variables that may
   *have been allocated by the parser.
   */
  xmlCleanupParser();
//free(xml_lesson_path);


}



